{"name":"Hamr","tagline":"Hadoop Annotated MapReduce (HAMR) is designed to simplify the development of shuffle phrase in Hadoop MapReduce ","body":"HAMR\r\n============\r\n   Hadoop Annotated MapReduce (HAMR) is designed to simplify the development of shuffle phrase in Hadoop MapReduce and let developers caring less about the details of the Hadoop implementation such as sort comparator, partitioner, and group comparator. \r\n\r\n#usage \r\n\r\nLet me explain the usage of HAMR with examples. All example code and data can be found [here][exampleCode].\r\n\r\n##1.secondary sorting with HAMR\r\n\r\n  Consider a situation like this: you want to make statistics on how long users stay in web pages. To do so, a script which will send a message to server in every 5 Sec is injected into each page. The format of message is like this: \r\n\r\nmessageTime###sessionId###url\r\n\r\nmessageTime is the time that the script sends that message; sessionid denote a single user; and the url is the page's url. \r\n\r\n  In usual cases, the MapReduce program should be designed that key-value pairs is sorted first by url, then sessionId, and refresh time. On Reduce side, key-value pairs is grouped by url and sessionId so that each reducer gets one visitor's track on one page which is sorted in time.Reducer recives groups like this:\r\n\r\nurl1 , sessionId1,10:00\r\n\r\nurl1 , sessionId1,10:05\r\n\r\n....\r\n\r\nurl1 , sessionId1,10:xx\r\n\r\n____________________(group 1)\r\n\r\nurl1 , sessionId2,10:05\r\n\r\nurl1 , sessionId2,10:10\r\n\r\n....\r\n\r\nurl1 , sessionId2,10:xx\r\n\r\n____________________(group 2)\r\n\r\nurl2 , sessionId1,10:05\r\n\r\nurl2 , sessionId1,10:10\r\n\r\n....\r\n\r\nurl2 , sessionId1,10:xx\r\n\r\n____________________(group 3)\r\n\r\n.....\r\n\r\n____________________(group n)\r\n\r\n  Reducer compares the time in first data it recived with the last one to decide how long the user stay on that page.\r\n\r\n  To finish all these works, you need to write mapper, reducer, sortComparator.....\r\n\r\n   HAMR makes it much more simple. First put the fields which used to exist in key and value class into a class which extended AnnotedBean class.\r\n```java\r\n    @Generator(keyGeneratorClass = VisitKeyGenerator.class)\r\n    @Counters(counters = { VisitTimeCounter.class })\r\n    public class VisitBean extends AnnotedBean {\r\n\t @SortField(level = 3)\r\n\t @GroupField\r\n\t private String url;\r\n\t\r\n\t @SortField(level = 2)\r\n\t @GroupField\r\n\t private String sessionId;\r\n\r\n\t @SortField(level = 1)\r\n\t private Long messageTime;\r\n\r\n\t @SkipIO\r\n\t private Long totalTime;\r\n    }\r\n```\r\n \r\n\r\n  Let me first explain annotations in each field. These annotations tell HAMR how to sort and group beans into reducers. @SortField denote the field should be used to sort. The parameter level denotes the priority of that field. The higher the level, the higher the priority. In this [example][exampleCode], url has the highest priority in sorting, which means compare result of sessionId will have no effect unless two beans have the same url.On default, FieldComparator is used to compare fields. If you want to custom your field comparator, you can assign it as a parameter of @SortField. For example:\r\n  \r\n```java\r\n    @SortField(comparator=yourComparator.class)\r\n```\r\nNote that your Comparator class must extend FieldComparator and returns only 1,0 or -1 in compare function.\r\n  The field totalTime is used to collect count result and is not read from mapper input. Thus, there is no necessary to pass it from mapper to reducer. @SkipIO is used to denote that this field need not to be transferred.\r\n\r\n  Reducer will receive these beans and pass them to Counters. Counters define what to do in reduce function. And different Counters may accomplish different jobs in reduce side. Thus, a reducer may contain several Counters. Counter classes are assigned by annotation @Counters on the subclasses of AnnotedBean. In this [example][exampleCode], there is only one counter that is written by user. The usage of some general Counters will be described in the next section.\r\n\r\n  Lets have a look how Counter classes look like\r\n  ```java\r\n  public class VisitTimeCounter extends Counter {\r\n\tprivate Long firstTime;\r\n\tprivate Long lastTime;\r\n\r\n\t@SuppressWarnings(\"rawtypes\")\r\n\tpublic VisitTimeCounter(Context context) {\r\n\t\tsuper(context);\r\n\t}\r\n\r\n\t@Override\r\n\tpublic void count(AnnotedBean ab) {\r\n\t\tLong time = ((VisitBean) ab).getMessageTime();\r\n\t\tif (firstTime == null) {\r\n\t\t\tfirstTime = time;\r\n\t\t}\r\n\t\tlastTime = time;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic boolean end(AnnotedBean ret) {\r\n\t\tif (firstTime != null && lastTime != null) {\r\n\t\t\t((VisitBean) ret).setTotalTime(lastTime - firstTime);\r\n\t\t\treturn true;\r\n\t\t} else {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n    }\r\n```\r\n\r\n  There is two functions need to be rewritten in Counter class: count() and end(). Reducer will give every AnnotedBean from shuffle to each Counter by invoking their count function. At the end, Reducer will call end function of each Counter. The input of end function is the last non-null AnnotedBean from shuffle phrase. The returned boolean value tells the Reducer wether to write the result or not (counter can call context.write as the context is passed to counter in their construction method).If the result need not be write by reducer, the function end() should return false.\r\n  Note that Counters are going to be a variable in reduce function, thus, the Counters will be built for each time reduce function is called. \r\n\r\n  As one shall suppose, there should be some class to generate these AnnotedBeans for HAMR. The @KeyGenerator is used to convert input key-value pair in map function to AnnotedBean. @KeyGenerator should point to a subclass of KeyGenerator. Here is the [example][exampleCode] KeyGenerator for visitTimeBean. The function generate() will gain the input of mapper and return a list of AnnotedBean.\r\n  \r\n```java\r\n    public class VisitKeyGenerator extends KeyGenerator{\r\n\t@SuppressWarnings(\"rawtypes\")\r\n\tpublic VisitKeyGenerator(Context context) {\r\n\t\tsuper(context);\r\n\t}\r\n\tpublic List<AnnotedBean> generate(Object keyin , Object valuein)\r\n\t{\r\n\t\tList<AnnotedBean> ret = new ArrayList<AnnotedBean>();\r\n\t\tString[] vals = valuein.toString().split(\"###\");\r\n\t\tVisitBean bean = new VisitBean();\r\n\t\tbean.setMessageTime(Long.parseLong(vals[0]));\r\n\t\tbean.setSessionId(vals[1]);\r\n\t\tbean.setUrl(vals[2]);\r\n\t\tret.add(bean);\r\n\t\treturn ret;\r\n\t}\r\n    }\r\n```\r\n  The last work is to assemble these things together into a job\r\n  \r\n```java\r\n    public class VisitTimeJob {\r\n\tpublic static void main(String[] args) throws Exception {\r\n\t\tConfiguration conf = new Configuration();\r\n\t    Job job = Job.getInstance(conf, \"visit time\");\r\n\t    GeneralJob.generalization(VisitBean.class, job);\r\n\t    FileInputFormat.addInputPath(job, new Path(args[0]));\r\n\t    FileOutputFormat.setOutputPath(job, new Path(args[1]));\r\n\t    System.exit(job.waitForCompletion(true) ? 0 : 1);\r\n\t}\r\n\r\n    }\r\n```\r\n  Note, that if you want to custom your Reducer, you can set your own Reducer class to the job after generazation() is called.\r\n\r\n  The [example][exampleCode] data is in examples/datas/visitdata.\r\n\r\n##2.general counters\r\n\r\n  To satisfy some common usage, HAMR provide some general Counters. \r\n###SumCounter\r\n  SumCounter count the total number of AnnotedBean received by reduce function. @TargetField is used to tell SumCounter where to put the result. Here is the [example][exampleCode] of use SumCounter in classical MapReduce program word count.\r\n  ```java\r\n    @Counters(counters = {SumCounter.class})\r\n    @Generator(keyGeneratorClass = WordKeyGenerator.class)\r\n    public class WordCountBean extends AnnotedBean{\r\n    \t@GroupField\r\n    \t@SortField\r\n    \tpublic String word;\r\n    \t\r\n    \t@SkipIO\r\n    \t@TargetField(generateFrom = SumCounter.class)\r\n    \tprivate Integer count;\r\n    \t\r\n    \tpublic String toString()\r\n    \t{\r\n    \t\treturn word + \"###\" + count;\r\n    \t}\r\n    }\r\n```\r\n\r\n###SetSumCounter\r\nSetSumCounter is used to count how many different value of a field presented in a reduce function. The ipcount in [example][exampleCode] code illustrate usage of this counter: you have got a web site's visitor data which contain a url and user's IP. And you want to know how many indentical IP had visited each url. This is how SetSumCounter is used in IpCountBean:\r\n```java\r\n    @Counters(counters = {SetSumCounter.class})\r\n    public class IpCountBean extends AnnotedBean{\r\n\t@SortField\r\n\t@GroupField\r\n\tprivate String url;\r\n\t@ReduceField(counterClass = {SetSumCounter.class})\r\n\tprivate String ip;\r\n\t@SkipIO\r\n\t@TargetField(generateFrom = SetSumCounter.class ,     fromField = \"ip\")\r\n\tprivate Integer ipNum;\r\n\t}\r\n```\r\nWhen generateFrom assigned as SetSumCounter.class, fromField must be the name of the counting fields. And there should be @ReduceField on the counting fields.\r\n\r\n##3.write a general counter\r\nThere are several functions provided in Counter that make writing a general counter easier. The maxtemprature in the [example][exampleCode] illustrated how to write a custom counter. Assume you have a file contains temperature of some cities in every day, and you need to calculate the max temperature of each city. As finding maximum number is a very common situation, it is worth to spend some time to write a general counter. \r\n```java\r\npublic class MaxTempratureCounter extends Counter{\r\n\tprivate Double MaxTemprature;\r\n\t@SuppressWarnings(\"rawtypes\")\r\n\tpublic MaxTempratureCounter(Context context) {\r\n\t\tsuper(context);\r\n\t\tMaxTemprature = 0.0;\r\n\t}\r\n\t\r\n\t@Override\r\n\tpublic void count(AnnotedBean key) {\r\n         Map<Field , ReduceField> allReduceField = key.getReduceField();\r\n         Field tempratureField = allReduceField.keySet().iterator().next();\r\n         try {\r\n\t\t\tDouble temprature = (Double) tempratureField.get(key);\r\n\t\t\tif(temprature > MaxTemprature)\r\n\t\t\t{\r\n\t\t\t\tMaxTemprature = temprature;\r\n\t\t\t}\r\n\t\t} catch (IllegalArgumentException e) {\r\n\t\t\te.printStackTrace();\r\n\t\t} catch (IllegalAccessException e) {\r\n\t\t\te.printStackTrace();\r\n\t\t}\r\n\t}\r\n\t\r\n\t@Override\r\n\tpublic boolean end(AnnotedBean ret)\r\n\t{\r\n\t\ttry {\r\n\t\t\tMap<Field , TargetField> allTargetField = getTargetFields(ret);\r\n\t\t\tallTargetField.keySet().iterator().next().set(ret, MaxTemprature);\r\n\t\t} catch (IllegalArgumentException e) {\r\n\t\t\te.printStackTrace();\r\n\t\t} catch (IllegalAccessException e) {\r\n\t\t\te.printStackTrace();\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n    }\r\n```\r\nThere getReduceField() function will return a Map object containing fields which have annotation @ReduceField && counterClass is assigned to current counter class. The function getTargetFields() returns similiar to getReduceField(), but it returns the fields which have @TargetField pointing to current counter. \r\n\r\n\r\n4.preducer\r\n//under construction\r\n\r\n\r\n[exampleCode]:https://github.com/citymonkeymao/harm-examples\r\n\r\n![tracking](http://getnotify.com/white.asp?eid=1483a959c3719abb)\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}